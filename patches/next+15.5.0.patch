// node_modules/next/dist/server/lib/trace/tracer.js

Object.defineProperty(exports, "__esModule", { value: true });

function _export(target, all) {
  for (var name in all) Object.defineProperty(target, name, {
    enumerable: true,
    get: all[name]
  });
}

_export(exports, {
  BubbledError: () => BubbledError,
  isBubbledError: () => isBubbledError,
  getTracer: () => getTracer
});

// No OpenTelemetry at all
const api = {
  context: { active: () => ({}), with: (_, fn) => fn(), bind: (_, fn) => fn },
  propagation: { inject: () => {}, extract: () => ({}) },
  trace: {
    getTracer: () => ({ startSpan: () => ({ end: () => {} }) }),
    getSpan: () => null,
    getSpanContext: () => null,
    setSpan: () => ({})
  },
  SpanStatusCode: { ERROR: 'ERROR' },
  SpanKind: { INTERNAL: 'INTERNAL' },
  ROOT_CONTEXT: {},
  createContextKey: () => Symbol('noop-key')
};

const { context, propagation, trace, SpanStatusCode, SpanKind, ROOT_CONTEXT, createContextKey } = api;

class BubbledError extends Error {
  constructor(bubble, result) {
    super();
    this.bubble = bubble;
    this.result = result;
  }
}

function isBubbledError(error) {
  if (typeof error !== 'object' || error === null) return false;
  return error instanceof BubbledError;
}

const closeSpanWithError = (span, error) => {
  if (isBubbledError(error) && error.bubble) {
    span.setAttribute?.('next.bubble', true);
  } else {
    span.setStatus?.({ code: SpanStatusCode.ERROR, message: error?.message });
  }
  span.end?.();
};

const rootSpanAttributesStore = new Map();
const rootSpanIdKey = createContextKey('next.rootSpanId');
let lastSpanId = 0;
const getSpanId = () => lastSpanId++;

class NextTracerImpl {
  getTracerInstance() {
    return trace.getTracer('next.js', '0.0.1');
  }

  getContext() {
    return context;
  }

  getActiveScopeSpan() {
    const activeContext = context.active();
    return trace.getSpan(activeContext);
  }

  withPropagatedContext(carrier, fn, getter) {
    const activeContext = context.active();
    if (trace.getSpanContext(activeContext)) return fn();
    const remoteContext = propagation.extract(activeContext, carrier, getter);
    return context.with(remoteContext, fn);
  }

  trace(type, fnOrOptions, fnOrEmpty) {
    const { fn, options } = typeof fnOrOptions === 'function'
      ? { fn: fnOrOptions, options: {} }
      : { fn: fnOrEmpty, options: { ...fnOrOptions } };

    return fn();
  }

  wrap(name, options = {}, fn) {
    return fn;
  }

  getSpanContext(span) {
    return span ?? this.getActiveScopeSpan();
  }
}

const getTracer = (() => {
  const tracer = new NextTracerImpl();
  return () => tracer;
})();
